fragment_downloaded_cb({"url":"switchbin/index.html#switchbin-page","fragment":"switchbin\nswitchbin is a helper element that chooses between a set of processing\nchains (called \"paths\") based on incoming caps, the caps of the paths,\nand the result of caps queries issued to the elements within the paths.\nIt switches between these paths based on thes caps. Paths are child objects,\nwhich are accessed by the GstChildProxy interface.\nThe intent is to allow for easy construction of dynamic pipelines that\nautomatically switches between paths based on the caps, which is useful\nfor cases when certain elements are only to be used for certain types\nof dataflow. One common example is a switchbin that inserts postprocessing\nelements only if the incoming caps are of a type that allows for such\npostprocessing, like when a video dataflow could be raw frames in some\ncases and encoded MPEG video in others - postprocessing plugins for\ncolor space conversion, scaling and such then should only be inserted\nif the data consists of raw frames, while encoded video is passed\nthrough unchanged.\nEach path has an \"element\" property. If a GstElement is passed to this,\nswitchbin takes ownership over that element. (Any previously set element\nis removed and unref'd before the new one is set.) The element property\ncan also be NULL for a special passthrough mode (see below). In addition,\neach path has a \"caps\" property, which is used for finding matching\npaths. These caps are referred to as the \"path caps\".\nNOTE: Currently, switchbin has a limitation that path elements must\nhave exactly one \"sink\" and one \"src\" pad, both of which need to be\nalways available, so no request and no sometimes pads.\nWhenever new input caps are encountered at the switchbin's sinkpad,\nthe first path with matching caps is picked. A \"match\" means that the\nresult of gst_caps_can_intersect is TRUE. The paths are looked at\nin order: path #0's caps are looked at first, checked against the new\ninput caps with gst_caps_can_intersect, and if the return value\nis TRUE, path #0 is picked. Otherwise, path #1's caps are looked at etc.\nIf no path matches, a GST_STREAM_ERROR_WRONG_TYPE error is reported.\nFor queries, the concept of \"allowed caps\" is important. These are the\ncaps that are possible to use with this switchbin. They are computed\ndifferently for sink- and for srcpads.\nAllowed sinkpad caps are computed by visiting each path, issuing an\ninternal caps query to the path element's sink pad, intersecting the\nresult from that query with the path caps, and appending that intersection\nto the overall allowed sinkpad caps. Allowed srcpad caps are similar,\nexcept that the result of the internal query is directly attached to the\noverall allowed srcpad caps (no intersection with path caps takes place):\nThe intuition behind this is that in sinkpad direction, only caps that\nare compatible with both the path caps and whatever the internal element\ncan handle are really usable - other caps will be rejected. In srcpad\ndirection, path caps do not exert an influence.\nThe switchbin responds to caps and accept-caps queries in a particular\nway. They involve the aforementioned \"allowed caps\".\nCaps queries are responded to by first checking if there are any paths.\nIf num-paths is 0, the query always fails. If there is no current path\nselected, or if the path has no element, the allowed sink/srcpad caps\n(depending on whether the query comes from the sink- or srcpad direction)\nis directly used as the response. If a current path is selected, and it\nhas an element, the query is forwarded to that element instead.\nAccept-caps queries are handled by checking if the switchbin can find\na path whose caps match the caps from that query. If there is one, the\nresponse to that query is TRUE, otherwise FALSE.\nAs mentioned before, path caps can in theory be any kind of caps. However,\nthey always only affect the input side (= the sink pad side of the switchbin).\nPath elements can produce output of any type, so their srcpad caps can be\nanything, even caps that are entirely different. For example, it is perfectly\nvalid if the path caps are \"video/x-raw\", the path element sink pad template\ncaps also are \"video/x-raw\", and the src pad caps of the elements are\n\"application/x-rtp\".\nPath elements can be set to NULL. Such paths perform dataflow passthrough.\nThe path then just forwards data. This includes caps and accept-caps queries.\nSince there is no element, the internal caps queries go to the switchbin\npeers instead (to the upstream peer when the query is at the switchbin's\nsrcpad, and to the downstream peer if the query is at the sinkpad).\nIn this example, if the data is raw PCM audio with 44.1 kHz, a volume\nelement is used for reducing the audio volume to 10%. Otherwise, it is\njust passed through. So, 44.1 kHz PCM audio will sound quiet, while\n48 kHz PCM and any non-PCM data will be passed through unmodified.\nThis example's path #1 is a passthrough path. Its caps are \"ANY\" caps,\nand its element is NULL (the default value). Dataflow is passed through,\nand caps and accept-caps queries are forwarded to the switchbin peers.\nNOTE: Setting the caps to NULL instead of ANY would have accompl√≠shed\nthe same in this example, since NULL path caps are internally\ninterpreted as ANY caps.\n"});