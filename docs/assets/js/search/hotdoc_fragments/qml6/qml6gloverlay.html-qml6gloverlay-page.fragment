fragment_downloaded_cb({"url":"qml6/qml6gloverlay.html#qml6gloverlay-page","fragment":"qml6gloverlay\nqml6gloverlay provides a way to render an almost-arbitrary QML scene within\nGStreamer pipeline using the same OpenGL context that GStreamer uses\ninternally.  This avoids attempting to share multiple OpenGL contexts\navoiding increased synchronisation points and attempting to share an OpenGL\ncontext at runtime which some drivers do not like.  The Intel driver on\nWindows is a notable example of the last point.\nqml6gloverlay will attempt to retrieve the windowing system display connection\nthat Qt is using (#GstGLDisplay).  This may be different to any already\nexisting window system display connection already in use in the pipeline for\na number of reasons.  A couple of examples of this are:\nIf one of these scenarios occurs, then there will be multiple OpenGL contexts\nin use in the pipeline.  This means that either the pipeline will fail to\nstart up correctly, a downstream element may reject buffers, or a complete\nGPU->System memory->GPU transfer is performed for every buffer.\nThe requirement to avoid this is that all elements share the same\nGstGLDisplay object and as Qt cannot currently share an existing window\nsystem display connection, GStreamer must use the window system display\nconnection provided by Qt.  This window system display connection can be\nretrieved by either a qml6glsink element, a qml6gloverlay, or a\nqml6glmixer element. The recommended usage is to have either element\n(qml6glsink or qml6gloverlay or qml6glmixer) be the first to propagate\nthe GstGLDisplay for the entire pipeline to use by setting either element\nto the READY element state before any other OpenGL element in the pipeline.\nIn the dynamically adding qml6gloverlay (or qml6glsink, or qml6glmixer)\nto a pipeline case, there are some considerations for ensuring that the\nwindow system display and OpenGL contexts are compatible with Qt.  When the\nqml6gloverlay (or qml6glsink, or qml6glmixer) element is added and\nbrought up to READY, it will propagate it's own GstGLDisplay using the\nGstContext mechanism regardless of any existing GstGLDisplay used by the\npipeline previously.  In order for the new GstGLDisplay to be used, the\napplication must then set the provided GstGLDisplay containing GstContext\non the pipeline.  This may effectively cause each OpenGL element to replace\nthe window system display and also the OpenGL context it is using.  As such\nthis process may take a significant amount of time and resources as objects\nare recreated in the new OpenGL context.\nAll instances of qml6gloverlay, qml6glsink, and qml6glmixer will\nreturn the exact same GstGLDisplay object while the pipeline is running\nregardless of whether any qml6gloverlay or qml6glsink elements are\nadded or removed from the pipeline.\nThe Qml scene will run at the pace of incoming buffers.  One input buffer\nwill cause a render of one output buffer.  The timestamps on the input\nbuffers are used to drive the animation time.\n"});