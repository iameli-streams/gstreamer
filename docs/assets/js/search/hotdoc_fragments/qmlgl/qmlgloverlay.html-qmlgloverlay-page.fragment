fragment_downloaded_cb({"url":"qmlgl/qmlgloverlay.html#qmlgloverlay-page","fragment":"qmlgloverlay\nqmlgloverlay provides a way to render an almost-arbitrary QML scene within\nGStreamer pipeline using the same OpenGL context that GStreamer uses\ninternally.  This avoids attempting to share multiple OpenGL contexts\navoiding increased synchronisation points and attempting to share an OpenGL\ncontext at runtime which some drivers do not like.  The Intel driver on\nWindows is a notable example of the last point.\nqmlgloverlay will attempt to retrieve the windowing system display connection\nthat Qt is using (#GstGLDisplay).  This may be different to any already\nexisting window system display connection already in use in the pipeline for\na number of reasons.  A couple of examples of this are:\nIf one of these scenarios occurs, then there will be multiple OpenGL contexts\nin use in the pipeline.  This means that either the pipeline will fail to\nstart up correctly, a downstream element may reject buffers, or a complete\nGPU->System memory->GPU transfer is performed for every buffer.\nThe requirement to avoid this is that all elements share the same\nGstGLDisplay object and as Qt cannot currently share an existing window\nsystem display connection, GStreamer must use the window system display\nconnection provided by Qt.  This window system display connection can be\nretrieved by either a qmlglsink element or a qmlgloverlay element. The\nrecommended usage is to have either element (qmlglsink or qmlgloverlay)\nbe the first to propagate the GstGLDisplay for the entire pipeline to use by\nsetting either element to the READY element state before any other OpenGL\nelement in the pipeline.\nIn a dynamically adding qmlgloverlay (or qmlglsink) to a pipeline case,\nthere are some considerations for ensuring that the window system display\nand OpenGL contexts are compatible with Qt.  When the qmlgloverlay (or\nqmlglsink) element is added and brought up to READY, it will propagate it's\nown GstGLDisplay using the GstContext mechanism regardless of any existing\nGstGLDisplay used by the pipeline previously.  In order for the new\nGstGLDisplay to be used, the application must then set the provided\nGstGLDisplay containing GstContext on the pipeline.  This may effectively\ncause each OpenGL element to replace the window system display and also the\nOpenGL context it is using.  As such this process may take a significant\namount of time and resources as objects are recreated in the new OpenGL\ncontext.\nAll instances of qmlgloverlay and qmlglsink will return the exact same\nGstGLDisplay object while the pipeline is running regardless of whether\nany qmlgloverlay or qmlglsink elements are added or removed from the\npipeline.\nThe Qml scene will run at the pace of incoming buffers.  One input buffer\nwill cause a render of one output buffer.  The timestamps on the input\nbuffers are used to drive the animation time.\n"});